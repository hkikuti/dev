const tips = [
  /*#####################################################
   * はじめに
   *#####################################################*/
  {
    category : "はじめに",
    datalist : [
      {
        "title" : "本規約について",
        "data" : [
            "本プロジェクトにおける、Javaのコーディング規約を以下に示す。",
            "本規約の目的は統一性と可読性・保守性を高めることであり、無条件に機械的な適用を強いるものではない。",
            "記述スタイルや実装方針において明確な意図や妥当性が認められる場合は、チーム内で相談の上で柔軟に対応することが望ましい。",
        ]
      }
    ]
  },
  /*#####################################################
   * コーディングスタイル
   *#####################################################*/
  {
    category : "コーディングスタイル",
    datalist : [
      {
        "title" : "インデント",
        "data" : [
            "・インデントには、IDEのデフォルト設定に準拠し、タブ文字を使用する。",
            "・スペースとタブの混在は認めない。",
        ]
      },
      {
        "title" : "行長",
        "data" : [
            "・1行の文字数制限は200文字とする。",
            "・以下の例外を除き、この制限を超える場合は「式の折り返し」で述べる方針に従って改行する。",
            { "explain" : [
                "【例外】",
                "・パッケージ文、インポート文など、途中改行が認められていない行。",
                "・改行によって可読性が著しく損なわれる場合。",
            ]},
        ]
      },
      {
        "title" : "式の折り返し",
        "data" : [
            "式が長くなる場合、以下のルールに従って改行する。",
            "&nbsp;",
            "・演算子（+, -, &&, ||, =, == など）は、演算子の前で改行する。",
            "e|例：",
            { "code" : [
                "boolean result = longConditionA",
                "    && longConditionB",
            ]},

            "・メソッドチェーンのドット（.）は、ドットの前で改行する。",
            "e|例：",
            { "code" : [
                "BigDecimal value = myObject",
                "    .getComponent()",
                "    .getValue();",
            ]},

            "・配列・引数リストのカンマ（,）は、カンマの後で改行する。",
            "e|例：",
            { "code" : [
                "List&lt;String&gt; names = Arrays.asList(",
                "    &quot;Alice&quot;,",
                "    &quot;Bob&quot;,",
                "    &quot;Charlie&quot;",
                ");",
            ]},
        ]
      },
      {
        "title" : "コードブロックの折り返し",
        "data" : [
            "コードブロック（中括弧 {} による制御）は以下のルールに従って改行する。",
            "&nbsp;",
            "・開始中括弧 { の前では改行しない。",
            "・開始中括弧 { の後で改行する。",
            "・終了中括弧 } の前で改行する。",
            "・終了中括弧 } の後の改行は、次に続く構文に応じて決定する。",
            { "explain" : [
                "&nbsp;",
                "・単一ブロックまたは複数ブロックの最後であれば改行する。",
                "・else や catch などの後続ブロックがある場合、改行せず、同じ行に続けて記述する。",
            ]},
            "e|例：",
            { "code" : [
                "if (condition) {",
                "    // ・・・",
                "} else {",
                "    // ・・・",
                "}",
            ]},
        ]
      },
      {
        "title" : "空行",
        "data" : [
            "・以下の位置には必ず空行を挿入する。",
            { "explain" : [
                "・package と import の間",
                "・クラス、インターフェース、enumの定義前",
                "・メソッドの定義前",
            ]},
            "・フィールド同士の間の空行は任意とする。",
            "・ただし、アノテーションの前には視認性の観点から空行の挿入を推奨する。",
        ]
      },
      {
        "title" : "空白文字（whitespace）",
        "data" : [
            "・二項演算子の前後に空白を入れる。",
            "e|良い例：",
            { "code" : [
                "int sum = a + b;",
            ]},
            "e|悪い例：",
            { "code" : [
                "int sum = a+b;",
            ]},
            "&nbsp;",

            "・カンマ（,）の後に空白を入れる。（前には入れない）",
            "e|良い例：",
            { "code" : [
                "callMethod(arg1, arg2, arg3);",
            ]},
            "e|悪い例：",
            { "code" : [
                "callMethod(arg1,arg2,arg3);",
                "callMethod(arg1 , arg2);",
            ]},
            "&nbsp;",

            "・セミコロン（;）の後に空白を入れる。（for文など）",
            "e|良い例：",
            { "code" : [
                "for (int i = 0; i < 10; i++) {",
                "    // ・・・",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "for (int i = 0;i < 10;i++) {",
                "    // ・・・",
                "}",
            ]},
            "&nbsp;",

            "・制御文のキーワード（if, for, whileなど）と括弧の間に空白を入れる。",
            "e|良い例：",
            { "code" : [
                "if (condition) {",
                "    // ・・・",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "if(condition) {",
                "    // ・・・",
                "}",
            ]},
            "&nbsp;",

            "・キャストの後に空白を入れる。",
            "e|良い例：",
            { "code" : [
                "int x = (int) value;",
            ]},
            "e|悪い例：",
            { "code" : [
                "int x = (int)value;",
            ]},
            "&nbsp;",

            "・配列添字やメソッド引数リストの括弧内先頭・末尾には空白を入れない。",
            "e|良い例：",
            { "code" : [
                "array[i + 1];",
                "methodCall(a, b);",
            ]},
            "e|悪い例：",
            { "code" : [
                "array[ i + 1 ];",
                "methodCall( a, b );",
            ]},
            "&nbsp;",

            "・中括弧{}の前後に空白を入れる。",
            "e|良い例：",
            { "code" : [
                "if (a > b) {",
                "    // ・・・",
                "} else {",
                "    // ・・・",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "if (a > b){",
                "    // ・・・",
                "}else{",
                "    // ・・・",
                "}",
            ]},
        ]
      },
      {
        "title" : "インポート",
        "data" : [
            "・ワイルドカード（*）を使用せず、明示的に指定すること。",
            "・import文は、パッケージの接頭辞ごとにグループ化し、グループ間に空行を挿入すること。",
            "　グループ化及び並び順は、IDEの保存アクションによる「インポートの編成」機能の使用を前提とする。",
            "・各import文は1行で記述し、途中で改行しないこと。",
            
        ]
      },
      {
        "title" : "静的インポート",
        "data" : [
            "・staticインポートは原則として禁止する。",
            "・staticインポートはコードを簡潔にする利点があるが、保守性の観点から推奨されない。主な理由は以下の通り。",
            { "explain" : [
                "・名前空間が不明瞭となり、参照元の判別が困難となる。",
                "・同名のメソッドやフィールドを持つ他クラスと競合し、意図しない動作を引き起こす可能性がある。",
                "・同様の処理であっても、静的インポートの有無によりコードに差異が生じ、一貫性が損なわれる。",
            ]},
        ]
      },
      {
        "title" : "ステートメント",
        "data" : [
            "・ステートメント（文）は1行毎に1つのみを原則とする。",
            "・なお、for文の初期化部や更新部など、文法上複数ステートメントが1行に含まれる場合はこの限りではない。",
            "e|良い例：",
            { "code" : [
                "methodCall(a);",
                "methodCall(b);",
            ]},
            "e|悪い例：",
            { "code" : [
                "methodCall(a); methodCall(b);",
            ]},
        ]
      },
      {
        "title" : "制御構造",
        "data" : [
            "・ステートメントのない空ブロックは利用しない。",
            "　分岐などでやむを得ずに処理なしのブロックが必要な場合は、コメントで補足する。",
            "e|良い例：",
            { "code" : [
                "if (condition) {",
                "    // この条件の場合、何もせずに次へ進む",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "if (condition) {",
                "}",
            ]},

            "・すべての switch に default を記述する。",
            "・case句ではフォールスルーを原則避ける。",
            "　フォールスルーが必要な場合は「fall through」という特別なコメントを必須とする。フォールスルーさせる直前の行に記述すること。",
            "e|良い例：",
            { "code" : [
                "switch (input) {",
                "case 1:",
                "    prepare();",
                "    // fall through",
                "case 2:",
                "    process(input);",
                "    break;",
                "default:",
                "    processDefault();",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "switch (input) {",
                "case 1:",
                "    prepare();",
                "case 2:",
                "    process(input);",
                "    break;",
                "}",
            ]},
        ]
      },
      {
        "title" : "修飾子の順序",
        "data" : [
            "・修飾子はJava言語仕様で推奨されている順序に記述すること。",
            "r|public, protected, private, abstract, static, final",
            "e|良い例：",
            { "code" : [
                "public static final int CONST_VALUE = 0;",
            ]},
            "e|悪い例：",
            { "code" : [
                "public final static int CONST_VALUE = 0;",
            ]},
        ]
      },
      {
        "title" : "変数の宣言",
        "data" : [
            "・1つのステートメントには1つの変数宣言のみ。",
            "e|良い例：",
            { "code" : [
                "String code;",
                "String name;",
            ]},
            "e|悪い例：",
            { "code" : [
                "String code, name;",
            ]},

            "・配列の宣言は 型名[] の形式にする。",
            { "explain" : [
                "・型名[] 形式は型定義と時点で配列であることを示せるため、型構造を直感的に把握しやすい。",
                "・変数名[] 形式でも宣言可能だが、一貫性を欠くため使用を認めない。",
            ]},
            "e|良い例：",
            { "code" : [
                "int[] valueArray = new int[5];",
            ]},
            "e|悪い例：",
            { "code" : [
                "int valueArray[] = new int[5];",
            ]},
        ]
      },
      {
        "title" : "変数の宣言位置",
        "data" : [
            "・ローカル変数は、原則として使用の直前に宣言する。",
            "・宣言と使用の間に他の処理が挟まると、可読性や意図の明確さを損なわれるため、避けるべきである。",
            "・また、変数のスコープを短く保つことで、誤代入や不要な使いまわしによるバグを防ぐ観点でも有用である。",
            "・なお、Checkstyleによる警告は一律のルールで表示される。パフォーマンスや可読性との兼ね合いにより、例外的に許容される場合もある。",
            "e|良い例：",
            { "code" : [
                "private void process() {",
                "    // ・・・",
                "    // ・・・",
                "    // ・・・",
                "    if (condition) {",
                "        int count = calculate();",
                "        output(count);",
                "    }",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "private void process() {",
                "    int count = calculate();",
                "    // ・・・",
                "    // ・・・",
                "    // ・・・",
                "    if (condition) {",
                "        output(count);",
                "    }",
                "}",
            ]},
        ]
      },
      {
        "title" : "varによる型推論の禁止",
        "data" : [
            "・ローカル変数の宣言において、varの使用は禁止する。例外的にも認めない。",
            "・varは冗長な型名を省略してコードを簡潔にできる利点があるが、以下の理由により使用を禁止する。",
            { "explain" : [
                "・varは初期化が必須であり、nullによる初期化ができないなどの制約が多いため、使用できないコードが必ず存在する。",
                "・varの使用・非使用が混在することで、コード全体の統一感が損なわれ、可読性が低下する。",
                "・明示的な型宣言を徹底することで、型推論による曖昧さを排除し、可読性・保守性を向上させる。",
            ]},
            "e|良い例：",
            { "code" : [
                "List&lt;String&gt; userList = new ArrayList&lt;&gt;();",
                "int userCount = 0;",
            ]},
            "e|悪い例：",
            { "code" : [
                "var userList = new ArrayList&lt;&gt;();",
                "var userCount = 0;",
            ]},
        ]
      },
      {
        "title" : "ファイナライザの禁止",
        "data" : [
            "・finalize() のオーバーライドは原則として禁止する。",
            "・finalize() はガベージコレクターによって自動的に呼び出されるが、",
            "　呼び出しのタイミングが不定であり、実行を保証できないためである。",
            "　また、オーバーライドによりプログラムの挙動が予測しにくくなり、ガベージコレクターのパフォーマンスを低下させる可能性もある。"
        ]
      },
      {
        "title" : "メソッドのオーバーロード順序",
        "data" : [
            "・同じ名前を持つメソッド（オーバーロード）は、他のメソッドやフィールドを挟まずに連続して記述する。",
            "・これにより、関連メソッドを視覚的に把握しやすくなり、可読性と保守性が向上する。",
            "e|良い例：",
            { "code" : [
                "public void setData() {",
                "    setData(1);",
                "}",
                "public void setData(int data) {",
                "    // ・・・",
                "}",
                "public void otherName() {",
                "    // ・・・",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "public void setData() {",
                "    setData(1);",
                "}",
                "public void otherName() {",
                "    // ・・・",
                "}",
                "public void setData(int data) {",
                "    // ・・・",
                "}",
            ]},
        ]
      },
      {
        "title" : "クラスメンバの定義順序",
        "data" : [
            "・クラス内における変数・メソッドの定義順は、以下を推奨する。",
            { "explain" : [
                "1.　クラス変数（static変数）",
                "2.　インスタンス変数",
                "3.　コンストラクタ",
                "4.　クラスメソッド（staticメソッド）",
                "5.　インスタンスメソッド",
            ]},
            "・同一カテゴリ内（例：インスタンスメソッド同士）では、アクセス修飾子の順に並べることを推奨する。",
            { "explain" : [
                "public > protected > private",
            ]},
            "・ただし、上記の順序は前項「メソッドのオーバーロード順序」と両立しない場合がある。",
            "　そのような場合、可読性と意図の明確さを優先し、柔軟に判断すること。",
            "&nbsp;",
            "・「新しいメソッドはクラス末尾に追加する」といった機械的な判断は避けること。",
            "　このような配置は視認性を下げ、保守性を損なうため、原則として認めない。",
        ]
      },
      {
        "title" : "リソースの解放",
        "data" : [
            "・リソースの解放が必要なクラスを利用する場合は、必ず try-with-resources 文を利用すること。",
            "・try-with-resources により、リソースの解放漏れを防ぐことができる。",
            "・対象のクラスが AutoCloseable を実装しているかどうかで、try-with-resources を利用すべきか判断できる。",
            "・AutoCloseable を実装していないクラスについては、finally等を用いて適切にリソースを解放する必要があることに留意すること。",
            "e|良い例：",
            { "code" : [
                "try (InputStream inputStream = Files.newInputStream(filePath)) {",
                "    // inputStreamに対する処理",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "InputStream inputStream = Files.newInputStream(filePath);",
                "try {",
                "    // inputStreamに対する処理",
                "} catch (IOException e) {",
                "    // 例外処理",
                "} finally {",
                "    inputStream.close();  // 明示的にclose()しているが、漏れや例外抑制の原因となる",
                "}",
            ]},
        ]
      },
    ]
  },
  /*#####################################################
   * 命名規則
   *#####################################################*/
  {
    category : "命名規則",
    datalist : [
      {
        "title" : "全般",
        "data" : [
            "・大文字・小文字の違いで名前を区別しないこと。",
            "e|良い例：",
            { "code" : [
                "private String userName;",
                "private String companyName;",
            ]},
            "e|悪い例：",
            { "code" : [
                "private String name;",
                "private String Name;",
            ]},

            "・変数名はスコープが狭くても、意味の明確な名称とする。",
            "　単に list とするよりも、内容が分かる名前の方が可読性が高まる。",
            "e|良い例：",
            { "code" : [
                "long activeUserCount;",
                "List&lt;String&gt; activeUserList;",
            ]},
            "e|悪い例：",
            { "code" : [
                "long c;",
                "List&lt;String&gt; list;",
            ]},

            "・for文のループカウンタには、慣例として1文字（i, j, kなど）を用いることを容認する。",
            "　ただし、ネストが深い場合や、ループカウンタの使用頻度が高い場合は、意味のある変数名を使うことが望ましい。",
        ]
      },
      {
        "title" : "パッケージ名",
        "data" : [
            "・パッケージ名はすべて小文字＋数字の組み合わせをドットで区切る形式とする（java標準に準拠）。",
            "・次の正規表現に一致する必要がある。",
            { "reference" : [
                "^[a-z]+(\.[a-z][a-z0-9]*)*$",
            ]},
        ]
      },
      {
        "title" : "クラス・インターフェース・列挙型名",
        "data" : [
            "・型定義名はパスカルケース（アッパーキャメルケース）とする。",
            "e|良い例：",
            { "code" : [
                "public class UserForm {",
            ]},
            "e|悪い例：",
            { "code" : [
                "public class userForm {",
            ]},
        ]
      },
      {
        "title" : "メソッド名",
        "data" : [
            "・メソッド名はキャメルケースとする。",
            "e|良い例：",
            { "code" : [
                "public String getUserName() {",
                "    // ・・・",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "public String GetUserName() {",
                "    // ・・・",
                "}",
            ]},
        ]
      },
      {
        "title" : "メンバ変数名",
        "data" : [
            "・非staticのメンバ変数名はキャメルケースとする。",
            "e|良い例：",
            { "code" : [
                "private String systemName;",
            ]},
            "e|悪い例：",
            { "code" : [
                "private String SystemName;",
                "private String SYSTEM_NAME;",
            ]},
        ]
      },
      {
        "title" : "定数名",
        "data" : [
            "・定数は static final を付け、アッパースネークケースとする。。",
            "・Javaやフレームワークで指定された特殊な定数（例：serialVersionUID）は例外とする。",
            "e|良い例：",
            { "code" : [
                "private static final int MAX_VALUE = 100;",
            ]},
            "e|悪い例：",
            { "code" : [
                "private static final int maxValue = 100;",
            ]},
        ]
      },
      {
        "title" : "ローカル変数名",
        "data" : [
            "・ローカル変数名はキャメルケースとする。",
            "・final で不変でも、定数と混同されないようスネークケースは禁止する。",
            "e|良い例：",
            { "code" : [
                "String userName;",
            ]},
            "e|悪い例：",
            { "code" : [
                "String UserName;",
                "final String USER_NAME;",
            ]},
        ]
      },
      {
        "title" : "catch句の例外変数名",
        "data" : [
            "・例外変数名はキャメルケースとする。",
            "・スコープが限定的であり可読性を損ねることもないため、慣習的に e の1文字を用いることを推奨する。",
            "e|良い例：",
            { "code" : [
                "} catch (Exception e) {",
            ]},
            "e|悪い例：",
            { "code" : [
                "} catch (Exception EX) {",
            ]},
        ]
      },
    ]
  },
  /*#####################################################
   * コメントの書き方
   *#####################################################*/
  {
    category : "コメントの書き方",
    datalist : [
      {
        "title" : "設計書の内容をそのまま書かない",
        "data" : [
            "・コメントは設計書とのマッピングを目的とするものではなく、コードの理解を補助するために記述すること。",
            "・設計書と一対一の対応を意図したコメントは適切ではない。",
            "・設計書とソースコードは成果物としての粒度が異なるため、",
            "　設計書の内容をそのまま引用すると、コメントの位置が不適切であったり、ソースコードに対する注釈が不明瞭になる可能性が高い。",
            "・また、設計書の項番や表現が変更された場合、コメントの意味や関連性が崩れてしまい、保守性が低下する。",
        ]
      },
      {
        "title" : "コードを日本語化したコメントを避ける",
        "data" : [
            "・各行のコードが「何をしているか」を逐一説明するコメントは不要である。",
            "・そのような処理内容はコードから読み取れるため、過剰な説明は可読性を損ねる。",
            "・コメントでは「何をしているか」よりも「何故そうしているか」を説明することが、保守性の向上に繋がる。",
            "e|良い例：",
            { "code" : [
                "if (!matcher.find()) {",
                "    // パターンに一致しない場合は10MBをデフォルトとして起動",
                "    return (10 * 1024 * 1024);",
                "}",
            ]},
            "e|悪い例：",
            { "code" : [
                "// マッチャーを判定",
                "if (!matcher.find()) {",
                "    // 計算した結果を返却",
                "    return (10 * 1024 * 1024);",
                "}",
            ]},
        ]
      },
      {
        "title" : "修正履歴としてのコメントアウトは禁止",
        "data" : [
            "・過去の修正履歴を目的に、不要となったコードをコメントアウトのまま残すことは可読性を著しく損ねるため禁止する。",
            "・変更履歴はバージョン管理システムによって管理することが原則のため、必要に応じてログや差分を参照すればよい。",
            "・コードは常に最新の状態を明示するものとし、これにより保守性を維持する。",
            "e|悪い例：",
            { "code" : [
                "// 2025/06/13 #XXXXの対応によりメソッド変更",
                "// doSomethingOld();",
                "doSomethingNew();",
            ]},
        ]
      },
      {
        "title" : "JavaDocコメント",
        "data" : [
            "h|JavaDocの適用範囲",
            "・JavaDocコメントは protected 以上のクラス・メソッドに必須とする。",
            "・privateメソッドは任意とするが、処理が複雑な場合は記述することが望ましい。",
            "&nbsp;",
            "h|タグの記述方針",
            "・@param、@return、@throws には、メソッドの仕様に即した正確な記述を行うこと。",
            "・単純で役割が明確なメソッドについては、タグの省略を許容する。",
            "&nbsp;",
            "h|アクセサの扱い",
            "・JavaBeansのアクセサについては、JavaDocコメント自体を省略を認める。",
        ]
      },
    ]
  },
]